<!-- Copyright (c) 2025 DeltaV Lab all rights reserved
 https://deltav-lab.org
 X: @DeltaV_Lab -->

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŸºæ¿ãŠçµµã‹ãå¤‰æ›ãƒ„ãƒ¼ãƒ«</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <!-- Info ãƒœã‚¿ãƒ³ -->
    <div class="info-button" id="infoButton">
        <span>i</span>
    </div>

    <!-- Info ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
    <div class="info-popup" id="infoPopup">
        <div class="info-content">
            <div class="info-header">
                <h3>About</h3>
                <button class="close-btn" id="closeInfo">Ã—</button>
            </div>
            <div class="info-body">
                <div class="info-section">
                    <h4>ğŸ“‹ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±</h4>
                    <p>ç”»åƒã‚’åŸºæ¿è£½é€ ç”¨ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è‡ªå‹•åˆ†é›¢ã™ã‚‹Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚</p>
                    <p><strong>ãƒãƒ¼ã‚¸ãƒ§ãƒ³:</strong> 1.0.0</p>
                    <p><strong>æœ€çµ‚æ›´æ–°æ—¥:</strong> 2025-09-04</p>
                    <p><strong>ãƒªãƒã‚¸ãƒˆãƒª:</strong> <a href="https://github.com/rei512/img2pcb" target="_blank" rel="noopener">https://github.com/rei512/img2pcb</a></p>
                </div>
                
                <div class="info-section">
                    <h4>âš–ï¸ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹</h4>
                    <p><strong>æœ¬Webãƒšãƒ¼ã‚¸:</strong> MIT License</p>
                    <button class="terms-btn" id="showTerms">åˆ©ç”¨è¦ç´„ã‚’è¡¨ç¤º</button>

                    <p><strong>JSZip:</strong> MIT License</p>
                    <p class="license-text">Copyright (c) 2009-2016 Stuart Knightley, David Duponchel, Franz Buchinger, AntÃ³nio Afonso</p>
                    <a href="https://github.com/Stuk/jszip" target="_blank" rel="noopener">JSZip GitHub â†’</a>
                    
                </div>
                
                <div class="info-section">
                    <h4>ğŸ‘¤ ä½œè€…æƒ…å ±</h4>
                    <div class="author-links">
                        <a href="https://deltav-lab.org" target="_blank" rel="noopener" class="author-link">
                            ğŸŒ ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸
                        </a>
                        <a href="https://x.com/DeltaV_Lab" target="_blank" rel="noopener" class="author-link">
                            Twitter(ç¾:ğ•) @DeltaV_Lab
                        </a>
                    </div>
                </div>
                
                <div class="info-section">
                    <h4>ğŸ’¡ How to use</h4>
                    <ol>
                        <li>åŸºæ¿ã‚¢ãƒ¼ãƒˆç”¨ã®ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</li>
                        <li>ã—ãã„å€¤ã‚’èª¿æ•´ï¼ˆä»»æ„ï¼‰</li>
                        <li>å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>

    <!-- åˆ©ç”¨è¦ç´„ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
    <div class="info-popup" id="termsPopup">
        <div class="info-content">
            <div class="info-header">
                <h3>åˆ©ç”¨è¦ç´„</h3>
                <button class="close-btn" id="closeTerms">Ã—</button>
            </div>
            <div class="info-body">
                <div class="info-section">
                    <h4>ğŸ”’ ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒãƒªã‚·ãƒ¼</h4>
                    <p>æœ¬ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸç”»åƒã‚’ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã®ã¿å‡¦ç†ã—ã€å¤–éƒ¨ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã™ã¹ã¦ã®å‡¦ç†ã¯ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å®Œçµã—ã¾ã™ã€‚</p>
                </div>
                
                <div class="info-section">
                    <h4>ğŸ“œ ä½¿ç”¨è¨±è«¾</h4>
                    <p>æœ¬ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®ä¸‹ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚å•†ç”¨ãƒ»éå•†ç”¨å•ã‚ãšè‡ªç”±ã«ã”åˆ©ç”¨ã„ãŸã ã‘ã¾ã™ã€‚</p>
                    <p>ãŸã ã—ã€æœ¬ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ä½¿ç”¨ã«ã‚ˆã‚Šç”Ÿã˜ãŸæå®³ã«ã¤ã„ã¦ã€ä½œè€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚</p>
                </div>
                
                <div class="info-section">
                    <h4>âš ï¸ å…è²¬äº‹é …</h4>
                    <p>æœ¬ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã¯ã€Œç¾çŠ¶ã®ã¾ã¾ã€æä¾›ã•ã‚Œã€å‹•ä½œã®ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
                    <p>ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€å®Ÿéš›ã®åŸºæ¿è£½é€ å‰ã«å¿…ãšæ¤œè¨¼ã—ã¦ãã ã•ã„ã€‚</p>
                </div>
                
                <div class="info-section">
                    <h4>ğŸ”„ æ›´æ–°ã«ã¤ã„ã¦</h4>
                    <p>æœ¬åˆ©ç”¨è¦ç´„ã¯äºˆå‘Šãªãå¤‰æ›´ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</p>
                    <p>ç¶™ç¶šã—ã¦ã”åˆ©ç”¨ã„ãŸã ãã“ã¨ã§ã€å¤‰æ›´å¾Œã®è¦ç´„ã«åŒæ„ã—ãŸã‚‚ã®ã¨ã¿ãªã—ã¾ã™ã€‚</p>
                </div>
                <p>Copyright (c) 2025 DeltaV Lab</p>
                <p><a href="https://licenses.opensource.jp/MIT/MIT.html" target="_blank" rel="noopener">MITãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã®å…¨æ–‡ã¯ã“ã¡ã‚‰</a></p>

                
            </div>
        </div>
    </div>

    <div class="container">
        <h1>åŸºæ¿ãŠçµµã‹ãå¤‰æ›ãƒ„ãƒ¼ãƒ«</h1>
        
        <!-- åŸºæ¿è‰²è¨­å®šã‚’éè¡¨ç¤ºã«ï¼ˆã‚³ãƒ¼ãƒ‰ã¯æ®‹ã™ï¼‰ -->
        <div class="input-section" style="display: none;">
            <h2>åŸºæ¿è‰²è¨­å®š</h2>
            <p>æš—ã„è‰²ã‹ã‚‰æ˜ã‚‹ã„è‰²ã®é †ã«è¨­å®šã—ã¦ãã ã•ã„</p>
            
            <div class="color-input">
                <label>ãƒ¬ã‚¤ãƒ¤ãƒ¼1 (æœ€æš—):</label>
                <input type="color" id="color1" value="#000000">
                <span>éŠ…ç®”æŠœã+ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Š</span>
            </div>
            <div class="color-input">
                <label>ãƒ¬ã‚¤ãƒ¤ãƒ¼2:</label>
                <input type="color" id="color2" value="#404040">
                <span>éŠ…ç®”ã‚ã‚Š+ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Š</span>
            </div>
            <div class="color-input">
                <label>ãƒ¬ã‚¤ãƒ¤ãƒ¼3:</label>
                <input type="color" id="color3" value="#808080">
                <span>éŠ…ç®”æŠœã+ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã</span>
            </div>
            <div class="color-input">
                <label>ãƒ¬ã‚¤ãƒ¤ãƒ¼4:</label>
                <input type="color" id="color4" value="#c0c0c0">
                <span>éŠ…ç®”ã‚ã‚Š+ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã</span>
            </div>
            <div class="color-input">
                <label>ãƒ¬ã‚¤ãƒ¤ãƒ¼5 (æœ€æ˜):</label>
                <input type="color" id="color5" value="#ffffff">
                <span>ã‚·ãƒ«ã‚¯</span>
            </div>
        </div>
        
        <div class="upload-area" id="uploadArea">
            <p id="uploadText">ç”»åƒã‚’ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹ã€ã‚¯ãƒªãƒƒã‚¯ã—ã¦é¸æŠã—ã¦ãã ã•ã„<br><br>
            <input type="file" id="fileInput" class="file-input" accept=".png,.jpg,.jpeg" />
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
            </button>
        </div>
        
        <div id="thresholdSection" class="threshold-section" style="display: none;">
            <h2>ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ†é›¢ã—ãã„å€¤èª¿æ•´</h2>
            <p>ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã§5ã¤ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¢ƒç•Œã‚’èª¿æ•´ã§ãã¾ã™ã€‚å¤‰æ›´ã¯å³åº§ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</p>
            
            <div class="unified-threshold">
                <label>æ˜åº¦ã—ãã„å€¤ (0=é»’ â†’ 255=ç™½)</label>
                <div class="unified-slider" id="unifiedSlider">
                    <div class="slider-track"></div>
                    <div class="layer-range" data-layer="0"></div>
                    <div class="layer-range" data-layer="1"></div>
                    <div class="layer-range" data-layer="2"></div>
                    <div class="layer-range" data-layer="3"></div>
                    <div class="layer-range" data-layer="4"></div>
                    <div class="slider-handle" data-threshold="0"></div>
                    <div class="slider-handle" data-threshold="1"></div>
                    <div class="slider-handle" data-threshold="2"></div>
                    <div class="slider-handle" data-threshold="3"></div>
                </div>
                <div class="slider-labels">
                    <span>ãƒ¬ã‚¤ãƒ¤ãƒ¼1<br>éŠ…ç®”æŠœã+ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Š</span>
                    <span>ãƒ¬ã‚¤ãƒ¤ãƒ¼2<br>éŠ…ç®”ã‚ã‚Š+ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Š</span>
                    <span>ãƒ¬ã‚¤ãƒ¤ãƒ¼3<br>éŠ…ç®”æŠœã+ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã</span>
                    <span>ãƒ¬ã‚¤ãƒ¤ãƒ¼4<br>éŠ…ç®”ã‚ã‚Š+ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã</span>
                    <span>ãƒ¬ã‚¤ãƒ¤ãƒ¼5<br>ã‚·ãƒ«ã‚¯</span>
                </div>
                <div class="threshold-values">
                    <div class="threshold-value">
                        <span>å¢ƒç•Œ1:</span>
                        <input type="number" class="threshold-input" id="threshold-0" value="64" min="0" max="255">
                    </div>
                    <div class="threshold-value">
                        <span>å¢ƒç•Œ2:</span>
                        <input type="number" class="threshold-input" id="threshold-1" value="128" min="0" max="255">
                    </div>
                    <div class="threshold-value">
                        <span>å¢ƒç•Œ3:</span>
                        <input type="number" class="threshold-input" id="threshold-2" value="192" min="0" max="255">
                    </div>
                    <div class="threshold-value">
                        <span>å¢ƒç•Œ4:</span>
                        <input type="number" class="threshold-input" id="threshold-3" value="230" min="0" max="255">
                    </div>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="resetThresholds()" style="padding: 8px 16px; font-size: 14px;">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
            </div>
        </div>

        <div id="previewSection" class="preview-section" style="display: none;">
            <div class="layer-previews">
                <div class="preview-item">
                    <h3>éŠ…ç®”ãƒ¬ã‚¤ãƒ¤ãƒ¼</h3>
                    <canvas id="copperCanvas"></canvas>
                    <button onclick="downloadLayer('copper')" class="download-btn">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>
                <div class="preview-item">
                    <h3>ãƒ¬ã‚¸ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼ (ãƒã‚¬)</h3>
                    <canvas id="resistCanvas"></canvas>
                    <button onclick="downloadLayer('resist')" class="download-btn">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>
                <div class="preview-item">
                    <h3>ã‚·ãƒ«ã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼</h3>
                    <canvas id="silkCanvas"></canvas>
                    <button onclick="downloadLayer('silk')" class="download-btn">ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
                </div>
                <div class="preview-item">
                    <h3>å…ƒç”»åƒ</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
            </div>
            <div class="main-preview">
                <div class="preview-item">
                    <h3>åŸºæ¿é©ç”¨ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3>
                    <div class="pcb-layers">
                        <canvas id="pcbPreviewCanvas" class="pcb-canvas"></canvas>
                    </div>
                    <button onclick="downloadAll()" class="download-btn-primary">å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ (ZIP)</button>
                </div>
            </div>
        </div>
        
    </div>

    <!-- ãƒ•ãƒƒã‚¿ãƒ¼ -->
    <footer class="footer">
        <p>Copyright Â© 2025 DeltaV Lab - All rights reserved</p>
    </footer>

    <script>
        let originalImage = null;
        let processedLayers = {};
        let uploadedFileName = '';

        // ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã¨ã‚¯ãƒªãƒƒã‚¯æ©Ÿèƒ½ã‚’åˆæœŸåŒ–
        function initializeUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠï¼ˆãƒœã‚¿ãƒ³ä»¥å¤–ã®éƒ¨åˆ†ï¼‰
            uploadArea.addEventListener('click', (e) => {
                if (e.target !== uploadArea.querySelector('.upload-btn')) {
                    fileInput.click();
                }
            });

            // ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('drag-over');
            });

            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã®å¤‰æ›´ã‚¤ãƒ™ãƒ³ãƒˆ
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            });
        }

        function handleFile(file) {
            // ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
            if (!file.type.startsWith('image/')) {
                alert('ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ä¿å­˜ï¼ˆæ‹¡å¼µå­ã‚’é™¤ãï¼‰
            uploadedFileName = file.name.replace(/\.[^/.]+$/, "");

            const reader = new FileReader();
            reader.onload = function(e) {
                originalImage = new Image();
                originalImage.onload = function() {
                    // ç”»åƒèª­ã¿è¾¼ã¿å¾Œã€å³åº§ã«å‡¦ç†ã‚’é–‹å§‹
                    processImage();
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }


        function processImage() {
            if (!originalImage) return;

            // å…ƒç”»åƒã‚’è¡¨ç¤º
            const originalCanvas = document.getElementById('originalCanvas');
            const originalCtx = originalCanvas.getContext('2d');
            originalCanvas.width = originalImage.width;
            originalCanvas.height = originalImage.height;
            originalCtx.drawImage(originalImage, 0, 0);

            // ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            const pixels = imageData.data;

            // ã—ãã„å€¤ã«ã‚ˆã‚‹åˆ†é›¢ã‚’ä½¿ç”¨ï¼ˆåˆæœŸå€¤ã¨çµ±ä¸€ï¼‰
            const layers = separateImageWithUnifiedThresholds(pixels, originalCanvas.width, originalCanvas.height);

            // å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‡¦ç†ã—ã¦å‡ºåŠ›ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
            processedLayers.copper = generateCopperLayer(layers);
            processedLayers.resist = generateResistLayer(layers);
            processedLayers.silk = generateSilkLayer(layers);

            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºï¼ˆãƒ¬ã‚¸ã‚¹ãƒˆã¯ãƒã‚¬ã®ã¾ã¾ï¼‰
            displayLayerPreview('copperCanvas', processedLayers.copper, originalCanvas.width, originalCanvas.height);
            displayLayerPreview('resistCanvas', processedLayers.resist, originalCanvas.width, originalCanvas.height);
            displayLayerPreview('silkCanvas', processedLayers.silk, originalCanvas.width, originalCanvas.height);

            // åŸºæ¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ç”Ÿæˆ
            generatePCBPreview(processedLayers, originalCanvas.width, originalCanvas.height);

            document.getElementById('previewSection').style.display = 'grid';
            document.getElementById('thresholdSection').style.display = 'block';
            
            // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’åˆæœŸåŒ–
            initializeSliders();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function colorDistance(color1, color2) {
            const dr = color1.r - color2.r;
            const dg = color1.g - color2.g;
            const db = color1.b - color2.b;
            return Math.sqrt(dr*dr + dg*dg + db*db);
        }

        function separateImageToLayers(pixels, width, height, targetColors) {
            const layers = Array(5).fill().map(() => new Uint8Array(width * height));

            for (let i = 0; i < pixels.length; i += 4) {
                const pixelColor = {
                    r: pixels[i],
                    g: pixels[i + 1],
                    b: pixels[i + 2]
                };

                // æœ€ã‚‚è¿‘ã„è‰²ã‚’è¦‹ã¤ã‘ã‚‹
                let minDistance = Infinity;
                let closestLayer = 0;

                for (let j = 0; j < targetColors.length; j++) {
                    const distance = colorDistance(pixelColor, targetColors[j]);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestLayer = j;
                    }
                }

                const pixelIndex = Math.floor(i / 4);
                layers[closestLayer][pixelIndex] = 255;
            }

            return layers;
        }

        function generateCopperLayer(layers) {
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã¨4ãŒéŠ…ç®”ã‚ã‚Š
            const copper = new Uint8Array(layers[0].length);
            for (let i = 0; i < copper.length; i++) {
                copper[i] = (layers[1][i] > 0 || layers[3][i] > 0) ? 0 : 255; // é»’=éŠ…ç®”ã‚ã‚Š
            }
            return copper;
        }

        function generateResistLayer(layers) {
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã¨2ãŒãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Šï¼ˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã¯ãƒã‚¬å‡ºåŠ›ï¼‰
            // ã‚·ãƒ«ã‚¯ï¼ˆãƒ¬ã‚¤ãƒ¤ãƒ¼5ï¼‰ãŒã‚ã‚‹éƒ¨åˆ†ã¯ãƒ¬ã‚¸ã‚¹ãƒˆã‚’æŠœã‹ãªã„
            const resist = new Uint8Array(layers[0].length);
            for (let i = 0; i < resist.length; i++) {
                const hasResist = layers[0][i] > 0 || layers[1][i] > 0;
                const hasSilk = layers[4][i] > 0;
                // ã‚·ãƒ«ã‚¯ãŒã‚ã‚‹éƒ¨åˆ†ã¯ãƒ¬ã‚¸ã‚¹ãƒˆã‚’æ®‹ã™ï¼ˆãƒã‚¬å‡ºåŠ›ã§ã¯0=ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Šï¼‰
                resist[i] = (hasResist || hasSilk) ? 255 : 0; // ãƒã‚¬: é»’=ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã
            }
            return resist;
        }


        function generateSilkLayer(layers) {
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼5ãŒã‚·ãƒ«ã‚¯
            const silk = new Uint8Array(layers[0].length);
            for (let i = 0; i < silk.length; i++) {
                silk[i] = layers[4][i] > 0 ? 0 : 255; // é»’=ã‚·ãƒ«ã‚¯ã‚ã‚Š
            }
            return silk;
        }

        function displayLayerPreview(canvasId, layerData, width, height) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;

            const imageData = ctx.createImageData(width, height);
            const pixels = imageData.data;

            for (let i = 0; i < layerData.length; i++) {
                const pixelIndex = i * 4;
                const value = layerData[i];
                pixels[pixelIndex] = value;     // R
                pixels[pixelIndex + 1] = value; // G
                pixels[pixelIndex + 2] = value; // B
                pixels[pixelIndex + 3] = 255;   // A
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function generatePCBPreview(layers, width, height) {
            const canvas = document.getElementById('pcbPreviewCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = width;
            canvas.height = height;

            // åŸºæ¿è‰²ï¼ˆç·‘ï¼‰ã‚’ãƒ™ãƒ¼ã‚¹ã«æç”»
            ctx.fillStyle = '#1a5d1a';
            ctx.fillRect(0, 0, width, height);

            const imageData = ctx.createImageData(width, height);
            const pixels = imageData.data;

            for (let i = 0; i < layers.copper.length; i++) {
                const pixelIndex = i * 4;
                const copperValue = layers.copper[i];
                const resistValue = layers.resist[i]; // ãƒã‚¬ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
                const silkValue = layers.silk[i];

                let r, g, b;

                // ã‚·ãƒ«ã‚¯ãŒæœ€å„ªå…ˆï¼ˆç´”ç™½ï¼‰
                if (silkValue === 0) { // ã‚·ãƒ«ã‚¯ã‚ã‚Š
                    r = 255; g = 255; b = 255;
                } 
                // ãƒ¬ã‚¸ã‚¹ãƒˆæŠœãéƒ¨åˆ† - ãƒã‚¬ãƒ‡ãƒ¼ã‚¿ã§ã¯é»’=ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã
                else if (resistValue === 0) { // ãƒ¬ã‚¸ã‚¹ãƒˆæŠœã
                    if (copperValue === 0) { // éŠ…ç®”ã‚ã‚Š â†’ éŠ€è‰²
                        r = 192; g = 192; b = 192; // éŠ€è‰²ï¼ˆéŠ…ç®”ã‚€ãå‡ºã—ï¼‰
                    } else { // éŠ…ç®”ãªã— â†’ åŸºæ¿ç´ æè‰²
                        r = 180; g = 140; b = 90; // åŸºæ¿ç´ æè‰²ï¼ˆæ˜ã‚‹ã‚ï¼‰
                    }
                }
                // ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Šéƒ¨åˆ†
                else { // resistValue === 255
                    if (copperValue === 0) { // éŠ…ç®”ã‚ã‚Š+ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Š â†’ æ˜ã‚‹ã„ç·‘ï¼ˆåŠé€æ˜åŠ¹æœï¼‰
                        r = 40; g = 100; b = 40; // ã‚„ã‚„æš—ã‚ã®ç·‘ï¼ˆãƒ¬ã‚¸ã‚¹ãƒˆè¶Šã—ã®éŠ…ç®”ï¼‰
                    } else { // éŠ…ç®”ãªã—+ãƒ¬ã‚¸ã‚¹ãƒˆã‚ã‚Š â†’ é€šå¸¸ã®åŸºæ¿è‰²
                        r = 15; g = 60; b = 15; // ã‚ˆã‚Šæš—ã„ãƒ¬ã‚¸ã‚¹ãƒˆè‰²ï¼ˆç·‘ï¼‰
                    }
                }

                pixels[pixelIndex] = r;
                pixels[pixelIndex + 1] = g;
                pixels[pixelIndex + 2] = b;
                pixels[pixelIndex + 3] = 255;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function downloadLayer(layerType) {
            if (!processedLayers[layerType] || !originalImage) return;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;

            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’æç”»
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const pixels = imageData.data;
            const layerData = processedLayers[layerType];

            for (let i = 0; i < layerData.length; i++) {
                const pixelIndex = i * 4;
                const value = layerData[i];
                pixels[pixelIndex] = value;     // R
                pixels[pixelIndex + 1] = value; // G
                pixels[pixelIndex + 2] = value; // B
                pixels[pixelIndex + 3] = 255;   // A
            }

            ctx.putImageData(imageData, 0, 0);

            canvas.toBlob(function(blob) {
                if (!blob) {
                    alert('ç”»åƒã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                    return;
                }
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const baseFileName = uploadedFileName || 'pcb_image';
                a.download = `${baseFileName}_${layerType}.png`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }

        async function downloadAll() {
            if (!processedLayers.copper || !processedLayers.resist || !processedLayers.silk || !originalImage) {
                alert('ã™ã¹ã¦ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå‡¦ç†ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                return;
            }

            const zip = new JSZip();
            const layerNames = {
                copper: 'éŠ…ç®”ãƒ¬ã‚¤ãƒ¤ãƒ¼',
                resist: 'ãƒ¬ã‚¸ã‚¹ãƒˆãƒ¬ã‚¤ãƒ¤ãƒ¼', 
                silk: 'ã‚·ãƒ«ã‚¯ãƒ¬ã‚¤ãƒ¤ãƒ¼'
            };

            const baseFileName = uploadedFileName || 'pcb_image';

            // å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ZIPã«è¿½åŠ 
            for (const [layerType, layerName] of Object.entries(layerNames)) {
                try {
                    const blob = await createLayerBlob(layerType);
                    if (blob) {
                        zip.file(`${baseFileName}_${layerType}.png`, blob);
                    }
                } catch (error) {
                    console.error(`${layerName}ã®ç”Ÿæˆã«å¤±æ•—:`, error);
                }
            }

            // åŸºæ¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚ZIPã«è¿½åŠ 
            try {
                const pcbBlob = await createPCBPreviewBlob();
                if (pcbBlob) {
                    zip.file(`${baseFileName}_preview.png`, pcbBlob);
                }
            } catch (error) {
                console.error('åŸºæ¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ç”Ÿæˆã«å¤±æ•—:', error);
            }

            // ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
            try {
                const zipBlob = await zip.generateAsync({ 
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: {
                        level: 6
                    },
                    platform: 'UNIX'
                });
                
                // ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«åã«åŸºã¥ã„ã¦ZIPãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
                const baseFileName = uploadedFileName || 'pcb_image';
                const filename = `${baseFileName}_layers.zip`;
                
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                
                // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å°‘ã—é…ã‚‰ã›ã‚‹
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            } catch (error) {
                console.error('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã«å¤±æ•—:', error);
                alert('ZIPãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }


        function createLayerBlob(layerType) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;

                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’æç”»
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                const pixels = imageData.data;
                const layerData = processedLayers[layerType];

                for (let i = 0; i < layerData.length; i++) {
                    const pixelIndex = i * 4;
                    const value = layerData[i];
                    pixels[pixelIndex] = value;     // R
                    pixels[pixelIndex + 1] = value; // G
                    pixels[pixelIndex + 2] = value; // B
                    pixels[pixelIndex + 3] = 255;   // A
                }

                ctx.putImageData(imageData, 0, 0);

                canvas.toBlob(resolve, 'image/png', 1.0);
            });
        }

        function createPCBPreviewBlob() {
            return new Promise((resolve) => {
                const sourceCanvas = document.getElementById('pcbPreviewCanvas');
                if (!sourceCanvas) {
                    resolve(null);
                    return;
                }

                // æ–°ã—ã„ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆã—ã¦ã‚³ãƒ”ãƒ¼
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = sourceCanvas.width;
                canvas.height = sourceCanvas.height;

                // åŸºæ¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼
                ctx.drawImage(sourceCanvas, 0, 0);

                canvas.toBlob(resolve, 'image/png', 1.0);
            });
        }

        // çµ±åˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼æ©Ÿèƒ½
        let thresholds = [64, 128, 192, 230];
        let dragState = { dragging: null, offset: 0 };

        function initializeSliders() {
            initializeUnifiedSlider();
        }

        function initializeUnifiedSlider() {
            const slider = document.getElementById('unifiedSlider');
            const handles = slider.querySelectorAll('.slider-handle');
            
            // åˆæœŸå€¤ã‚’å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰å–å¾—ï¼ˆåŒæœŸç¢ºä¿ï¼‰
            for (let i = 0; i < 4; i++) {
                const input = document.getElementById(`threshold-${i}`);
                if (input && input.value) {
                    thresholds[i] = parseInt(input.value);
                }
            }
            
            // åˆæœŸè¡¨ç¤ºã‚’æ›´æ–°
            updateUnifiedSliderDisplay();
            updateInputValues();
            
            // ãƒãƒ³ãƒ‰ãƒ«ã®ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½
            handles.forEach((handle, index) => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    dragState.dragging = index;
                    handle.classList.add('active');
                    
                    const rect = slider.getBoundingClientRect();
                    dragState.offset = e.clientX - rect.left - (thresholds[index] / 255) * rect.width;
                    
                    document.addEventListener('mousemove', handleUnifiedSliderMove);
                    document.addEventListener('mouseup', handleUnifiedSliderUp);
                });
            });

            // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨ã®åŒæœŸ
            for (let i = 0; i < 4; i++) {
                const input = document.getElementById(`threshold-${i}`);
                input.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    if (value >= 0 && value <= 255) {
                        thresholds[i] = value;
                        sortThresholds();
                        updateUnifiedSliderDisplay();
                        updateInputValues();
                        updatePreviewsInRealTime();
                    }
                });
            }
        }

        function handleUnifiedSliderMove(e) {
            if (dragState.dragging === null) return;

            const slider = document.getElementById('unifiedSlider');
            const rect = slider.getBoundingClientRect();
            const x = e.clientX - rect.left - dragState.offset;
            const value = Math.round((x / rect.width) * 255);
            
            thresholds[dragState.dragging] = Math.max(0, Math.min(255, value));
            updateUnifiedSliderDisplay();
            updateInputValues();
            updatePreviewsInRealTime();
        }

        function handleUnifiedSliderUp() {
            if (dragState.dragging !== null) {
                const handles = document.getElementById('unifiedSlider').querySelectorAll('.slider-handle');
                handles[dragState.dragging].classList.remove('active');
                dragState.dragging = null;
                sortThresholds();
                updateUnifiedSliderDisplay();
                updateInputValues();
            }
            
            document.removeEventListener('mousemove', handleUnifiedSliderMove);
            document.removeEventListener('mouseup', handleUnifiedSliderUp);
        }

        function sortThresholds() {
            thresholds.sort((a, b) => a - b);
        }

        function updateUnifiedSliderDisplay() {
            const slider = document.getElementById('unifiedSlider');
            const handles = slider.querySelectorAll('.slider-handle');
            const ranges = slider.querySelectorAll('.layer-range');

            // ãƒãƒ³ãƒ‰ãƒ«ã®ä½ç½®ã‚’æ›´æ–°
            handles.forEach((handle, index) => {
                const percentage = (thresholds[index] / 255) * 100;
                handle.style.left = `${percentage}%`;
            });

            // ãƒ¬ã‚¤ãƒ¤ãƒ¼ç¯„å›²ã‚’æ›´æ–°
            const layerThresholds = [0, ...thresholds, 255];
            ranges.forEach((range, index) => {
                const leftPercent = (layerThresholds[index] / 255) * 100;
                const rightPercent = (layerThresholds[index + 1] / 255) * 100;
                range.style.left = `${leftPercent}%`;
                range.style.width = `${rightPercent - leftPercent}%`;
            });
        }

        function updateInputValues() {
            for (let i = 0; i < 4; i++) {
                document.getElementById(`threshold-${i}`).value = thresholds[i];
            }
        }

        function resetThresholds() {
            thresholds = [64, 128, 192, 230];
            updateUnifiedSliderDisplay();
            updateInputValues();
            updatePreviewsInRealTime();
        }

        function updatePreviewsInRealTime() {
            if (!originalImage) return;

            // ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const originalCanvas = document.getElementById('originalCanvas');
            const originalCtx = originalCanvas.getContext('2d');
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            const pixels = imageData.data;

            // ã—ãã„å€¤ã«ã‚ˆã‚‹åˆ†é›¢
            const layers = separateImageWithUnifiedThresholds(pixels, originalCanvas.width, originalCanvas.height);

            // ãƒ¬ã‚¤ãƒ¤ãƒ¼å‡¦ç†
            processedLayers.copper = generateCopperLayer(layers);
            processedLayers.resist = generateResistLayer(layers);
            processedLayers.silk = generateSilkLayer(layers);

            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
            displayLayerPreview('copperCanvas', processedLayers.copper, originalCanvas.width, originalCanvas.height);
            displayLayerPreview('resistCanvas', processedLayers.resist, originalCanvas.width, originalCanvas.height);
            displayLayerPreview('silkCanvas', processedLayers.silk, originalCanvas.width, originalCanvas.height);

            // åŸºæ¿ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
            generatePCBPreview(processedLayers, originalCanvas.width, originalCanvas.height);
        }

        function separateImageWithUnifiedThresholds(pixels, width, height) {
            const layers = Array(5).fill().map(() => new Uint8Array(width * height));

            for (let i = 0; i < pixels.length; i += 4) {
                const pixelColor = {
                    r: pixels[i],
                    g: pixels[i + 1],
                    b: pixels[i + 2]
                };

                const brightness = Math.round(0.299 * pixelColor.r + 0.587 * pixelColor.g + 0.114 * pixelColor.b);
                let assignedLayer = 0;

                // ã—ãã„å€¤ã§å±¤ã‚’æ±ºå®š
                for (let j = 0; j < 4; j++) {
                    if (brightness <= thresholds[j]) {
                        assignedLayer = j;
                        break;
                    }
                    assignedLayer = j + 1;
                }

                const pixelIndex = Math.floor(i / 4);
                layers[assignedLayer][pixelIndex] = 255;
            }

            return layers;
        }

        // Info ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—æ©Ÿèƒ½
        function initializeInfoPopup() {
            const infoButton = document.getElementById('infoButton');
            const infoPopup = document.getElementById('infoPopup');
            const closeInfo = document.getElementById('closeInfo');
            const showTerms = document.getElementById('showTerms');
            const termsPopup = document.getElementById('termsPopup');
            const closeTerms = document.getElementById('closeTerms');

            // Info ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
            infoButton.addEventListener('click', () => {
                infoPopup.style.display = 'flex';
            });

            // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’éè¡¨ç¤º
            closeInfo.addEventListener('click', () => {
                infoPopup.style.display = 'none';
            });

            // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’éè¡¨ç¤º
            infoPopup.addEventListener('click', (e) => {
                if (e.target === infoPopup) {
                    infoPopup.style.display = 'none';
                }
            });

            // åˆ©ç”¨è¦ç´„ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§åˆ©ç”¨è¦ç´„ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
            showTerms.addEventListener('click', () => {
                infoPopup.style.display = 'none';
                termsPopup.style.display = 'flex';
            });

            // åˆ©ç”¨è¦ç´„ã®é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
            closeTerms.addEventListener('click', () => {
                termsPopup.style.display = 'none';
            });

            // åˆ©ç”¨è¦ç´„ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯
            termsPopup.addEventListener('click', (e) => {
                if (e.target === termsPopup) {
                    termsPopup.style.display = 'none';
                }
            });

            // ESCã‚­ãƒ¼ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’éè¡¨ç¤º
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (infoPopup.style.display === 'flex') {
                        infoPopup.style.display = 'none';
                    }
                    if (termsPopup.style.display === 'flex') {
                        termsPopup.style.display = 'none';
                    }
                }
            });
        }

        // DOMContentLoadedæ™‚ã«åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initializeUpload();
            initializeInfoPopup();
        });
    </script>
</body>
</html>